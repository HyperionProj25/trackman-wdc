<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TrackMan Tableau WDC - v12.3-SingleDayPractice</title>
  <script src="https://connectors.tableau.com/libs/tableauwdc-2.3.latest.js"></script>
  <script>
    // Fallback for WDC library load error
    if (typeof tableau === 'undefined') {
      console.error('WDC: Tableau WDC library not loaded initially.');
      document.addEventListener('DOMContentLoaded', function() {
        const errDiv = document.getElementById('error-message');
        if (errDiv) {
            errDiv.style.display = 'block';
            errDiv.innerHTML = "<strong>Error:</strong> Tableau WDC library failed to load. Ensure you're running this in Tableau Desktop and have an internet connection.";
        }
      });
    }

    // ======= CONFIGURATION =======
    const config = {
        clientId: 'SheldonMcClelland-baseline',
        clientSecret: '889de571-86db-4c56-a640-e88cd4565526',
        oauthUrl: 'https://login.trackmanbaseball.com/connect/token',
        apiBase: 'https://dataapi.trackmanbaseball.com/api/v1', // Corrected API base
        proxyUrl: 'https://tmapi.netlify.app/.netlify/functions/trackman-proxy?url=',
        useTestData: false,
        schemaIdPitchData: 'TrackManPitchData_v12_Practice' // Schema ID for practice data
    };

    // ======= OAUTH TOKEN HANDLING =======
    function getOAuthToken() {
        console.log("WDC: Attempting to fetch new OAuth token.");
        const proxiedTokenUrl = config.proxyUrl + encodeURIComponent(config.oauthUrl);
        const bodyParams = new URLSearchParams();
        bodyParams.append('grant_type', 'client_credentials');
        bodyParams.append('client_id', config.clientId);
        bodyParams.append('client_secret', config.clientSecret);

        console.log("WDC: Requesting token from proxied URL:", proxiedTokenUrl.split("?url=")[0] + "?url=" + decodeURIComponent(proxiedTokenUrl.split("?url=")[1]));

        return fetch(proxiedTokenUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json'
            },
            body: bodyParams.toString()
        })
        .then(response => {
            console.log("WDC: getOAuthToken - Raw response status from proxy:", response.status);
            if (!response.ok) {
                return response.text().then(text => {
                    console.error("WDC: getOAuthToken - Error response text from proxy:", text.substring(0, 500));
                    let errorMessage = `Token request via proxy failed: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = JSON.parse(text);
                        if(errorData.error && errorData.error.details) {
                             errorMessage += ` - Proxy Error: ${errorData.error.details}`;
                        } else if (errorData.body) {
                            try {
                                const actualError = JSON.parse(errorData.body);
                                errorMessage += ` - Target Error: ${actualError.error_description || actualError.error || String(errorData.body).substring(0,100)}`;
                            } catch (e_parse_body) {
                                errorMessage += ` - Target Response (unparsable): ${String(errorData.body).substring(0,100)}`;
                            }
                        } else if (errorData.error) {
                            errorMessage += ` - Error: ${errorData.error}`;
                        }
                    } catch (e_parse) {
                        errorMessage += ` - Raw Text: ${text.substring(0, 100)}`;
                    }
                    throw new Error(errorMessage);
                });
            }
            return response.json();
        })
        .then(proxyResponseData => {
            console.log("WDC: getOAuthToken - Full response object from proxy (first 500 chars):", JSON.stringify(proxyResponseData).substring(0,500));
            let tokenData;
            if (proxyResponseData && typeof proxyResponseData.body === 'string') {
                try { tokenData = JSON.parse(proxyResponseData.body); }
                catch (e) { console.error("WDC: Failed to parse token data from proxy's response body string:", proxyResponseData.body.substring(0,500)); throw new Error("Failed to parse token data (body was string)."); }
            } else if (proxyResponseData && typeof proxyResponseData.body === 'object' && proxyResponseData.body !== null) {
                tokenData = proxyResponseData.body;
            } else if (proxyResponseData && proxyResponseData.access_token) {
                tokenData = proxyResponseData;
            } else {
                console.error("WDC: Token data not found in expected proxy response structure. Proxy response:", JSON.stringify(proxyResponseData).substring(0,500));
                throw new Error("Token data not found in expected proxy response structure.");
            }

            if (tokenData.error) { throw new Error(tokenData.error_description || tokenData.error || "Unknown OAuth error."); }
            if (!tokenData.access_token) { throw new Error("Access token not found in OAuth response."); }
            console.log("WDC: New OAuth access_token fetched successfully.");
            if (tokenData.expires_in) { console.log(`WDC: Token expires_in: ${tokenData.expires_in}s. Approx expiry: ${new Date(Date.now() + tokenData.expires_in * 1000)}`); }
            tableau.password = tokenData.access_token;
            return tokenData.access_token;
        })
        .catch(error => {
            console.error("WDC: Critical Error in getOAuthToken:", error.toString());
            return Promise.reject(error);
        });
    }

    // ======= TABLEAU WDC LOGIC =======
    const myConnector = tableau.makeConnector();

    myConnector.init = function(initCallback) {
        console.log("WDC: myConnector.init called. Tableau phase:", tableau.phase);
        initCallback();
    };

    myConnector.getSchema = function(schemaCallback) {
        console.log("WDC: myConnector.getSchema called (v12.3-SingleDayPractice).");
        const pitchCols = [
            // IDs and Timestamps
            { id: 'sessionId',        dataType: tableau.dataTypeEnum.string, alias: "Session ID" },
            { id: 'playId',           dataType: tableau.dataTypeEnum.string, alias: "Play/Pitch UID" }, // For practice, this might be pitchUID or hitUID
            { id: 'trackId',          dataType: tableau.dataTypeEnum.string, alias: "Track ID" }, // If available in practice data
            { id: 'trackStartTime',   dataType: tableau.dataTypeEnum.datetime, alias: "Approx. Track Start Time" }, // May need to derive or use session time for practice
            // Pitch Type and Call (Practice context)
            { id: 'kind',             dataType: tableau.dataTypeEnum.string, alias: "Kind (Pitch/Hit)" }, // trackType from practice data
            { id: 'taggedPitchType',  dataType: tableau.dataTypeEnum.string, alias: "Tagged Pitch Type" }, // From practice plays
            // Player Names (From Practice Plays Data)
            { id: 'pitcherName',      dataType: tableau.dataTypeEnum.string, alias: "Pitcher Name" }, // e.g., playInfo.pitcher.pitcher
            { id: 'batterName',       dataType: tableau.dataTypeEnum.string, alias: "Batter Name" },   // e.g., playInfo.batter.batter (often null for bullpens)
            // Practice Session Context
            { id: 'pitchNo',          dataType: tableau.dataTypeEnum.int, alias: "Pitch Number (in session/PA)" }, // from taggerBehavior in practice plays
            // Common Metrics (ensure paths are correct for Practice Pitch Data structure)
            { id: 'relSpeed',         dataType: tableau.dataTypeEnum.float, alias: "Release Speed" },
            { id: 'spinRate',         dataType: tableau.dataTypeEnum.float, alias: "Spin Rate" },
            { id: 'extension',        dataType: tableau.dataTypeEnum.float, alias: "Extension" },
            { id: 'vertRelAngle',     dataType: tableau.dataTypeEnum.float, alias: "Vertical Release Angle" },
            { id: 'horzRelAngle',     dataType: tableau.dataTypeEnum.float, alias: "Horizontal Release Angle" },
            { id: 'relHeight',        dataType: tableau.dataTypeEnum.float, alias: "Release Height" },
            { id: 'relSide',          dataType: tableau.dataTypeEnum.float, alias: "Release Side" },
            { id: 'horzBreak',        dataType: tableau.dataTypeEnum.float, alias: "Horizontal Break" }, // from pitch.trajectory for practice
            { id: 'vertBreak',        dataType: tableau.dataTypeEnum.float, alias: "Vertical Break" },   // from pitch.trajectory for practice
            { id: 'inducedVertBreak', dataType: tableau.dataTypeEnum.float, alias: "Induced Vertical Break" }, // from pitch.trajectory for practice
            { id: 'spinAxis',         dataType: tableau.dataTypeEnum.float, alias: "Spin Axis" },        // from pitch.release for practice
            { id: 'tilt',             dataType: tableau.dataTypeEnum.string, alias: "Tilt (Clock)" },   // from pitch.release for practice
            { id: 'zoneTime',         dataType: tableau.dataTypeEnum.float, alias: "Zone Time" },
            { id: 'plateLocHeight',   dataType: tableau.dataTypeEnum.float, alias: "Plate Location Height" },
            { id: 'plateLocSide',     dataType: tableau.dataTypeEnum.float, alias: "Plate Location Side" },
            { id: 'zoneSpeed',        dataType: tableau.dataTypeEnum.float, alias: "Zone Speed" },
            { id: 'vertApprAngle',    dataType: tableau.dataTypeEnum.float, alias: "Vertical Approach Angle" },
            { id: 'horzApprAngle',    dataType: tableau.dataTypeEnum.float, alias: "Horizontal Approach Angle" },
            { id: 'pfxx',             dataType: tableau.dataTypeEnum.float, alias: "pfx_x" },
            { id: 'pfxz',             dataType: tableau.dataTypeEnum.float, alias: "pfx_z" },
            { id: 'effVelocity',      dataType: tableau.dataTypeEnum.float, alias: "Effective Velocity" },
            // Fields specific to Practice 3D spin if available
            { id: 'spinAxis3dTilt',               dataType: tableau.dataTypeEnum.string, alias: "3D Tilt" },
            { id: 'spinAxis3dActiveSpinRate',   dataType: tableau.dataTypeEnum.float, alias: "3D Active Spin Rate" },
            { id: 'spinAxis3dSpinEfficiency',   dataType: tableau.dataTypeEnum.float, alias: "3D Spin Efficiency" },
            // Session Info (If needed per row, otherwise could be a separate table)
            { id: 'sessionGameDateUtc',      dataType: tableau.dataTypeEnum.datetime, alias: "Session Game Date UTC" },
            { id: 'sessionType',      dataType: tableau.dataTypeEnum.string, alias: "Session Type" }
        ];
        const tableInfoPitch = {
            id: config.schemaIdPitchData,
            alias: `TrackMan Practice Data ${config.schemaIdPitchData.split('_')[1]}`,
            columns: pitchCols
        };
        schemaCallback([tableInfoPitch]);
    };

    myConnector.getData = function(table, doneCallback) {
        console.log("WDC: Single Day Practice Test - getData called for table:", table.tableInfo.id);
        tableau.reportProgress("Single Day Practice Test: Attempting token...");

        getOAuthToken()
            .then(async freshToken => {
                console.log("WDC: Single Day Practice Test - Token fetched.");
                tableau.password = freshToken;

                if (table.tableInfo.id === config.schemaIdPitchData) {
                    fetchSingleDayPracticeData(table, doneCallback);
                } else {
                    tableau.abortWithError("WDC: Unknown table ID: " + table.tableInfo.id);
                }
            })
            .catch(error => {
                console.error("WDC: Single Day Practice Test - Error during token fetch:", error.toString());
                tableau.abortWithError("Single Day Practice Test FAILED (Token Error): " + error.toString());
            });
    };

    async function fetchSingleDayPracticeData(table, doneCallback) {
        console.log("WDC: fetchSingleDayPracticeData called.");
        try {
            let allRowsCollected = [];
            let sessionsFoundOverall = 0;

            // ======= !!! IMPORTANT: SET YOUR TARGET DATE FOR PRACTICE DATA HERE !!! =======
            // Format: "YYYY-MM-DD"
            const targetDateString = "2025-05-16"; // EXAMPLE: REPLACE THIS with a known practice day!
            // ======= !!! END OF TARGET DATE SETTING !!! =======

            const utcDateFrom = targetDateString + "T00:00:00Z";
            const utcDateTo = targetDateString + "T23:59:59Z";

            console.log(`WDC: Fetching PRACTICE Data for Single Day: ${targetDateString}`);
            tableau.reportProgress(`Discovering PRACTICE sessions for ${targetDateString}...`);

            const sessionsUrl = config.proxyUrl + encodeURIComponent(`${config.apiBase}/discovery/practice/sessions`); // PRACTICE endpoint
            let sessionsResponse;
            try {
                sessionsResponse = await fetch(sessionsUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json-patch+json',
                        'Accept': 'application/json',
                        'Authorization': 'Bearer ' + tableau.password
                    },
                    body: JSON.stringify({ sessionType: 'All', utcDateFrom, utcDateTo }) // 'All', 'Pitching', 'Hitting' are valid for practice
                });
            } catch (fetchError) {
                console.error(`WDC: Fetch to proxy for practice session discovery failed:`, fetchError.toString());
                tableau.abortWithError(`Network error (Practice Session Discovery): ${fetchError.toString()}.`);
                return; 
            }
            
            console.log(`WDC: Practice session discovery - proxy response status: ${sessionsResponse.status}`);
            if (!sessionsResponse.ok) {
                const errorText = await sessionsResponse.text();
                console.warn(`WDC: Practice session discovery failed (API). Status: ${sessionsResponse.status}, Body: ${errorText.substring(0, 200)}`);
                tableau.abortWithError(`API Error (Practice Session Discovery Status ${sessionsResponse.status}): ${errorText.substring(0,100)}`);
                return;
            }

            const sessionsData = await sessionsResponse.json();
            let actualSessions;
            if (sessionsData && sessionsData.body) { // Netlify proxy wraps response
                if (typeof sessionsData.body === 'string') {
                    try { actualSessions = JSON.parse(sessionsData.body); }
                    catch (e) { console.error(`WDC: Failed to parse practice sessionsData.body:`, e); actualSessions = []; }
                } else { actualSessions = sessionsData.body; }
            } else { actualSessions = sessionsData; } // Fallback if not wrapped

            if (!actualSessions || !Array.isArray(actualSessions) || actualSessions.length === 0) {
                console.log(`WDC: No PRACTICE sessions found in API for ${targetDateString}. Response:`, actualSessions);
                tableau.log(`No PRACTICE sessions found for ${targetDateString}.`);
                table.appendRows([{ statusMessage: `No PRACTICE sessions found for ${targetDateString}` }]); // Add a status row
                doneCallback();
                return; 
            }
            
            sessionsFoundOverall = actualSessions.length;
            console.log(`WDC: Found ${sessionsFoundOverall} PRACTICE sessions for ${targetDateString}.`);
            tableau.log(`Found ${sessionsFoundOverall} PRACTICE sessions.`);

            const sessionsToProcess = actualSessions.slice(0, 5); // Process up to 5 sessions for this test
            
            for (const session of sessionsToProcess) {
                if (!session.sessionId) { console.warn("WDC: Practice session missing sessionId:", session); continue; }
                tableau.reportProgress(`Processing PRACTICE session ${session.sessionId.substring(0,8)}...`);

                // 1. Fetch Practice Ball Data
                let actualBallData = [];
                const ballDataUrl = config.proxyUrl + encodeURIComponent(`${config.apiBase}/data/practice/balls/${session.sessionId}`); // PRACTICE endpoint
                console.log(`WDC: Fetching practice ball data for session: ${session.sessionId}`);
                try {
                    const ballResponse = await fetch(ballDataUrl, { headers: { 'Accept': 'application/json', 'Authorization': 'Bearer ' + tableau.password }});
                    if (ballResponse.ok) {
                        const ballDataResult = await ballResponse.json();
                        actualBallData = (ballDataResult && typeof ballDataResult.body === 'string' ? JSON.parse(ballDataResult.body) : ballDataResult.body) || ballDataResult;
                        if (!Array.isArray(actualBallData)) actualBallData = [];
                        console.log(`WDC: Fetched ${actualBallData.length} practice ball entries for session ${session.sessionId}.`);
                    } else { console.warn(`WDC: Practice ball data fetch failed. Status: ${ballResponse.status}`); }
                } catch (e) { console.error(`WDC: Error fetching practice ball data:`, e.toString()); }

                // 2. Fetch Practice Plays Data
                let actualPlaysData = [];
                const playsUrl = config.proxyUrl + encodeURIComponent(`${config.apiBase}/data/practice/plays/${session.sessionId}`); // PRACTICE endpoint
                console.log(`WDC: Fetching practice plays data for session: ${session.sessionId}`);
                 try {
                    const playsResponse = await fetch(playsUrl, { headers: { 'Accept': 'application/json', 'Authorization': 'Bearer ' + tableau.password }});
                    if (playsResponse.ok) {
                        const playsResult = await playsResponse.json();
                        actualPlaysData = (playsResult && typeof playsResult.body === 'string' ? JSON.parse(playsResult.body) : playsResult.body) || playsResult;
                        if (!Array.isArray(actualPlaysData)) actualPlaysData = [];
                        console.log(`WDC: Fetched ${actualPlaysData.length} practice plays for session ${session.sessionId}.`);
                    } else { console.warn(`WDC: Practice plays data fetch failed. Status: ${playsResponse.status}`);}
                } catch (e) { console.error(`WDC: Error fetching practice plays data:`, e.toString()); }
                
                // 3. Map and Combine (Focus on "Pitch" type from ball data)
                if (actualBallData && actualBallData.length > 0) {
                    const mappedRows = actualBallData
                        .filter(item => item.trackType === 'Pitch') // Practice "Ball" data has trackType: "Pitch" or "Hit"
                        .map(item => {
                            const playInfo = Array.isArray(actualPlaysData) ? actualPlaysData.find(p => p.playID === item.pitch?.pitchUID) : null; // playID in practice plays, pitchUID in practice ball data.
                            
                            return { 
                                sessionId: session.sessionId,
                                sessionGameDateUtc: session.gameDateUtc, // From session discovery
                                sessionType: session.sessionType,      // From session discovery
                                playId: item.pitch?.pitchUID || item.trackId, // Use pitchUID if available
                                trackId: item.trackId, 
                                trackStartTime: session.gameDateUtc, // Practice pitch data (p13) doesn't show individual trackStartTime, use session time as approx.
                                kind: item.trackType, // "Pitch"
                                
                                relSpeed: item.pitch?.release?.relSpeed,
                                spinRate: item.pitch?.release?.spinRate,
                                extension: item.pitch?.release?.extension,
                                vertRelAngle: item.pitch?.release?.vertRelAngle,
                                horzRelAngle: item.pitch?.release?.horzRelAngle,
                                relHeight: item.pitch?.release?.relHeight,
                                relSide: item.pitch?.release?.relSide,
                                
                                horzBreak: item.pitch?.trajectory?.horzBreak,
                                vertBreak: item.pitch?.trajectory?.vertBreak,
                                inducedVertBreak: item.pitch?.trajectory?.inducedVertBreak,
                                spinAxis: item.pitch?.release?.spinAxis,
                                tilt: item.pitch?.release?.tilt,
                                
                                zoneTime: item.pitch?.location?.zoneTime,
                                plateLocHeight: item.pitch?.location?.plateLocHeight,
                                plateLocSide: item.pitch?.location?.plateLocSide,
                                zoneSpeed: item.pitch?.location?.zoneSpeed,
                                vertApprAngle: item.pitch?.location?.vertApprAngle,
                                horzApprAngle: item.pitch?.location?.horzApprAngle,
                                
                                pfxx: item.pitch?.pfxData?.pfxx,
                                pfxz: item.pitch?.pfxData?.pfxz,
                                effVelocity: item.pitch?.pfxData?.effVelocity,

                                spinAxis3dTilt: item.pitch?.release?.spinAxis3dTilt,
                                spinAxis3dActiveSpinRate: item.pitch?.release?.spinAxis3dActiveSpinRate,
                                spinAxis3dSpinEfficiency: item.pitch?.release?.spinAxis3dSpinEfficiency,

                                pitcherName: playInfo?.pitcher?.pitcher, // From practice play data (PDF p14)
                                batterName: playInfo?.batter?.batter,   // From practice play data (PDF p14)
                                pitchNo: playInfo?.taggerBehavior?.pitchNo, // From practice play data
                                taggedPitchType: playInfo?.pitchTag?.taggedPitchType, // From practice play data
                                // pitchCall is not in practice play data example
                                pitchCall: null, 
                                // Inning, balls, strikes, outs not typically in practice context
                                inning: null, balls: null, strikes: null, outs: null,
                                statusMessage: `Data for session ${session.sessionId.substring(0,8)}`
                            };
                        });
                    allRowsCollected = allRowsCollected.concat(mappedRows);
                }
            } 
            if (allRowsCollected.length > 0) {
                console.log(`WDC: Appending ${allRowsCollected.length} PRACTICE pitch rows to Tableau.`);
                table.appendRows(allRowsCollected);
            } else {
                console.log(`WDC: No processable PRACTICE pitch data found for ${targetDateString}.`);
                if (sessionsFoundOverall > 0) {
                    tableau.log(`Found ${sessionsFoundOverall} practice sessions, but no pitch data extracted.`);
                }
                // No explicit tableau.log if no sessions, as it's logged above.
            }
            doneCallback();

        } catch (error) {
            console.error("WDC: Error in fetchSingleDayPracticeData:", error.toString(), error.stack);
            tableau.abortWithError("Failed during single day PRACTICE data fetch: " + error.toString());
        }
    }

    // Register the connector
    if (typeof tableau !== 'undefined' && tableau.makeConnector) {
        tableau.registerConnector(myConnector);
        console.log("WDC: Connector registered with Tableau.");
    } else {
        console.error('WDC: Cannot register connector: tableau object or tableau.makeConnector not available.');
        document.addEventListener('DOMContentLoaded', function() {
            const errDiv = document.getElementById('error-message');
            if (errDiv) errDiv.style.display = 'block';
            const button = document.getElementById('connectButton');
            if (button) button.disabled = true;
        });
    }
  </script>
</head>
<body>
  <h1>TrackMan Tableau WDC - v12.3-SingleDayPractice</h1>
  <div id="error-message" style="display:none; color:red; margin:10px 0; padding:10px; border: 1px solid red;">
  </div>
  <p><strong>Mode:</strong> Single Day PRACTICE Session Discovery & Data Fetch.</p>
  <p style="font-weight:bold; color:orange;">IMPORTANT: Edit the `targetDateString` in the `index.html` code to a known PRACTICE data day before testing!</p>
  <button id="connectButton" onclick="if(typeof tableau !== 'undefined' && tableau.connectionName !== undefined) { tableau.connectionName='TrackMan API v12.3-Practice'; tableau.submit(); } else { alert('This button must be run within Tableau Desktop\'s Web Data Connector interface.'); }">
    Run Single Day Practice Data Test
  </button>
</body>
</html>
