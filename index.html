<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TrackMan Tableau Web Data Connector v12</title>
  <script src="https://connectors.tableau.com/libs/tableauwdc-2.3.latest.js"></script>
  <script>
    // Fallback for WDC library load error
    if (typeof tableau === 'undefined') {
      console.error('WDC: Tableau WDC library not loaded initially.');
      document.addEventListener('DOMContentLoaded', function() {
        const errDiv = document.getElementById('error-message');
        if (errDiv) {
            errDiv.style.display = 'block';
            errDiv.innerHTML = "<strong>Error:</strong> Tableau WDC library failed to load. Ensure you're running this in Tableau Desktop and have an internet connection.";
        }
      });
    }

    // ======= CONFIGURATION =======
    const config = {
        clientId: 'SheldonMcClelland-baseline',
        clientSecret: '889de571-86db-4c56-a640-e88cd4565526',
        oauthUrl: 'https://login.trackmanbaseball.com/connect/token',
        apiBase: 'https://dataapi.trackmanbaseball.com/api/v1', // Using dataapi as per PDF
        proxyUrl: 'https://tmapi.netlify.app/.netlify/functions/trackman-proxy?url=',
        useTestData: false,
        schemaIdPitchData: 'TrackManPitchData_v12' // Updated schema ID
    };

    // ======= OAUTH TOKEN HANDLING =======
    function getOAuthToken() {
        console.log("WDC: Attempting to fetch new OAuth token.");
        const proxiedTokenUrl = config.proxyUrl + encodeURIComponent(config.oauthUrl);
        const bodyParams = new URLSearchParams();
        bodyParams.append('grant_type', 'client_credentials');
        bodyParams.append('client_id', config.clientId);
        bodyParams.append('client_secret', config.clientSecret);

        console.log("WDC: Requesting token from proxied URL:", proxiedTokenUrl.split("?url=")[0] + "?url=" + decodeURIComponent(proxiedTokenUrl.split("?url=")[1]));

        return fetch(proxiedTokenUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Accept': 'application/json'
            },
            body: bodyParams.toString()
        })
        .then(response => {
            console.log("WDC: getOAuthToken - Raw response status from proxy:", response.status);
            if (!response.ok) {
                return response.text().then(text => {
                    console.error("WDC: getOAuthToken - Error response text from proxy:", text.substring(0, 500));
                    let errorMessage = `Token request via proxy failed: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = JSON.parse(text);
                        if(errorData.error && errorData.error.details) {
                             errorMessage += ` - Proxy Error: ${errorData.error.details}`;
                        } else if (errorData.body) {
                            try {
                                const actualError = JSON.parse(errorData.body);
                                errorMessage += ` - Target Error: ${actualError.error_description || actualError.error || String(errorData.body).substring(0,100)}`;
                            } catch (e_parse_body) {
                                errorMessage += ` - Target Response (unparsable): ${String(errorData.body).substring(0,100)}`;
                            }
                        } else if (errorData.error) {
                            errorMessage += ` - Error: ${errorData.error}`;
                        }
                    } catch (e_parse) {
                        errorMessage += ` - Raw Text: ${text.substring(0, 100)}`;
                    }
                    throw new Error(errorMessage);
                });
            }
            return response.json();
        })
        .then(proxyResponseData => {
            console.log("WDC: getOAuthToken - Full response object from proxy (first 500 chars):", JSON.stringify(proxyResponseData).substring(0,500));
            let tokenData;
            if (proxyResponseData && typeof proxyResponseData.body === 'string') {
                try {
                    tokenData = JSON.parse(proxyResponseData.body);
                } catch (e) {
                    console.error("WDC: Failed to parse token data from proxy's response body string:", proxyResponseData.body.substring(0,500));
                    throw new Error("Failed to parse token data from proxy response (body was string).");
                }
            } else if (proxyResponseData && typeof proxyResponseData.body === 'object' && proxyResponseData.body !== null) {
                tokenData = proxyResponseData.body;
            } else if (proxyResponseData && proxyResponseData.access_token) {
                tokenData = proxyResponseData;
            } else {
                console.error("WDC: Token data not found in expected proxy response structure. Proxy response:", JSON.stringify(proxyResponseData).substring(0,500));
                throw new Error("Token data not found in expected proxy response structure.");
            }

            if (tokenData.error) {
                console.error("WDC: OAuth Error (from token endpoint):", tokenData.error, tokenData.error_description);
                throw new Error(tokenData.error_description || tokenData.error || "Unknown OAuth error from token endpoint.");
            }
            if (!tokenData.access_token) {
                console.error("WDC: access_token not found in processed OAuth response:", tokenData);
                throw new Error("Access token not found in processed OAuth response.");
            }
            console.log("WDC: New OAuth access_token fetched successfully.");
            if (tokenData.expires_in) {
                const expiryDate = new Date(Date.now() + tokenData.expires_in * 1000);
                console.log(`WDC: Token expires_in: ${tokenData.expires_in}s. Approx expiry: ${expiryDate} (Client Time)`);
            }
            tableau.password = tokenData.access_token;
            return tokenData.access_token;
        })
        .catch(error => {
            console.error("WDC: Critical Error in getOAuthToken:", error.toString());
            return Promise.reject(error);
        });
    }

    // ======= TABLEAU WDC LOGIC =======
    const myConnector = tableau.makeConnector();

    myConnector.init = function(initCallback) {
        console.log("WDC: myConnector.init called. Tableau phase:", tableau.phase);
        initCallback();
    };

    myConnector.getSchema = function(schemaCallback) {
        console.log("WDC: myConnector.getSchema called.");
        const pitchCols = [
            // IDs and Timestamps
            { id: 'sessionId',        dataType: tableau.dataTypeEnum.string, alias: "Session ID" },
            { id: 'playId',           dataType: tableau.dataTypeEnum.string, alias: "Play ID" },
            { id: 'trackId',          dataType: tableau.dataTypeEnum.string, alias: "Track ID" },
            { id: 'trackStartTime',   dataType: tableau.dataTypeEnum.datetime, alias: "Track Start Time" },
            // Pitch Type and Call
            { id: 'kind',             dataType: tableau.dataTypeEnum.string, alias: "Kind (Pitch/Hit)" }, // From Ball Data
            { id: 'taggedPitchType',  dataType: tableau.dataTypeEnum.string, alias: "Tagged Pitch Type" }, // From Plays or Ball Data
            { id: 'pitchCall',        dataType: tableau.dataTypeEnum.string, alias: "Pitch Call" }, // From Plays or Ball Data
            // Player Names (NEW - From Plays Data)
            { id: 'pitcherName',      dataType: tableau.dataTypeEnum.string, alias: "Pitcher Name" },
            { id: 'batterName',       dataType: tableau.dataTypeEnum.string, alias: "Batter Name" },
            // Game State (NEW - Primarily from Plays Data, fallback to Ball Data)
            { id: 'inning',           dataType: tableau.dataTypeEnum.int, alias: "Inning" },
            { id: 'balls',            dataType: tableau.dataTypeEnum.int, alias: "Balls (Count)" },
            { id: 'strikes',          dataType: tableau.dataTypeEnum.int, alias: "Strikes (Count)" },
            { id: 'outs',             dataType: tableau.dataTypeEnum.int, alias: "Outs" },
            { id: 'pitchNo',          dataType: tableau.dataTypeEnum.int, alias: "Pitch Number" }, // This is often PA of Inning or Pitch of PA
            // Release Metrics
            { id: 'relSpeed',         dataType: tableau.dataTypeEnum.float, alias: "Release Speed" },
            { id: 'spinRate',         dataType: tableau.dataTypeEnum.float, alias: "Spin Rate" },
            { id: 'extension',        dataType: tableau.dataTypeEnum.float, alias: "Extension" },
            { id: 'vertRelAngle',     dataType: tableau.dataTypeEnum.float, alias: "Vertical Release Angle" },
            { id: 'horzRelAngle',     dataType: tableau.dataTypeEnum.float, alias: "Horizontal Release Angle" },
            { id: 'relHeight',        dataType: tableau.dataTypeEnum.float, alias: "Release Height" },
            { id: 'relSide',          dataType: tableau.dataTypeEnum.float, alias: "Release Side" },
            // Movement Metrics
            { id: 'horzBreak',        dataType: tableau.dataTypeEnum.float, alias: "Horizontal Break" },
            { id: 'vertBreak',        dataType: tableau.dataTypeEnum.float, alias: "Vertical Break" },
            { id: 'inducedVertBreak', dataType: tableau.dataTypeEnum.float, alias: "Induced Vertical Break" },
            { id: 'spinAxis',         dataType: tableau.dataTypeEnum.float, alias: "Spin Axis" },
            { id: 'tilt',             dataType: tableau.dataTypeEnum.string, alias: "Tilt (Clock)" },
            // Location Metrics
            { id: 'zoneTime',         dataType: tableau.dataTypeEnum.float, alias: "Zone Time" },
            { id: 'plateLocHeight',   dataType: tableau.dataTypeEnum.float, alias: "Plate Location Height" },
            { id: 'plateLocSide',     dataType: tableau.dataTypeEnum.float, alias: "Plate Location Side" },
            { id: 'zoneSpeed',        dataType: tableau.dataTypeEnum.float, alias: "Zone Speed" },
            { id: 'vertApprAngle',    dataType: tableau.dataTypeEnum.float, alias: "Vertical Approach Angle" },
            { id: 'horzApprAngle',    dataType: tableau.dataTypeEnum.float, alias: "Horizontal Approach Angle" },
            // PFX Data
            { id: 'pfxx',             dataType: tableau.dataTypeEnum.float, alias: "pfx_x" },
            { id: 'pfxz',             dataType: tableau.dataTypeEnum.float, alias: "pfx_z" },
            { id: 'effVelocity',      dataType: tableau.dataTypeEnum.float, alias: "Effective Velocity" }
        ];
        const tableInfoPitch = {
            id: config.schemaIdPitchData,
            alias: `TrackMan Pitch Data ${config.schemaIdPitchData.split('_')[1]}`, // e.g., TrackMan Pitch Data v12
            columns: pitchCols
        };
        schemaCallback([tableInfoPitch]);
    };

    myConnector.getData = function(table, doneCallback) {
        console.log("WDC: myConnector.getData called for table:", table.tableInfo.id);

        getOAuthToken()
            .then(freshToken => {
                console.log("WDC: Fresh token successfully obtained/refreshed for getData call.");
                if (config.useTestData) {
                    // ... (test data logic can be added here if needed) ...
                    console.log('WDC: useTestData is true, but no test data implemented in this version for historical load.');
                    doneCallback();
                    return;
                }
                if (table.tableInfo.id === config.schemaIdPitchData) {
                    fetchAllDataHistorically(table, doneCallback);
                } else {
                    tableau.abortWithError("WDC: Unknown table ID in getData: " + table.tableInfo.id);
                }
            })
            .catch(error => {
                console.error("WDC: Failed to get/refresh token in getData:", error.toString());
                tableau.abortWithError("Authentication failed: " + error.toString());
            });
    };

            // In index.html, REPLACE the ENTIRE fetchAllDataHistorically function with this:
            async function fetchAllDataHistorically(table, doneCallback) {
                console.log("WDC: fetchAllDataHistorically called (v12.2 - Single Day Test).");
                if (!tableau.password) {
                    tableau.abortWithError("WDC: Authentication token is missing for data fetch.");
                    return;
                }
            
                try {
                    let allRowsCollected = [];
                    let sessionsFoundOverall = 0;
                    let pitchesFoundOverall = 0;
            
                    // ======= !!! IMPORTANT: SET YOUR TARGET DATE HERE !!! =======
                    // Your business partner should provide this date.
                    // Format: "YYYY-MM-DD"
                    const targetDateString = "2024-07-10"; // EXAMPLE DATE - REPLACE THIS!
                    // ======= !!! END OF TARGET DATE SETTING !!! =======
            
                    const utcDateFrom = targetDateString + "T00:00:00Z";
                    const utcDateTo = targetDateString + "T23:59:59Z";
            
                    console.log(`WDC: --- Fetching Data for Single Day ---`);
                    console.log(`WDC: Date Range for Session Discovery: ${utcDateFrom} to ${utcDateTo}`);
                    tableau.reportProgress(`Discovering sessions for ${targetDateString}`);
            
                    const sessionsUrl = config.proxyUrl + encodeURIComponent(`${config.apiBase}/discovery/game/sessions`);
                    let sessionsResponse;
                    try {
                        sessionsResponse = await fetch(sessionsUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json-patch+json',
                                'Accept': 'application/json',
                                'Authorization': 'Bearer ' + tableau.password
                            },
                            body: JSON.stringify({ sessionType: 'All', utcDateFrom, utcDateTo })
                        });
                    } catch (fetchError) {
                        console.error(`WDC: Outer fetch to proxy for session discovery failed:`, fetchError.toString());
                        tableau.abortWithError(`Network error during session discovery for ${targetDateString}: ${fetchError.toString()}. Check Netlify logs.`);
                        return; 
                    }
                    
                    console.log(`WDC: Sessions discovery proxy response status: ${sessionsResponse.status}`);
                    if (!sessionsResponse.ok) {
                        const errorText = await sessionsResponse.text();
                        console.warn(`WDC: Session discovery failed (API level) for ${targetDateString}. Status: ${sessionsResponse.status}, Body: ${errorText.substring(0, 200)}`);
                        tableau.abortWithError(`Session discovery failed for ${targetDateString} (Status ${sessionsResponse.status}): ${errorText.substring(0,100)}`);
                        return;
                    }
            
                    const sessionsData = await sessionsResponse.json();
                    let actualSessions;
                    if (sessionsData && sessionsData.body) {
                        if (typeof sessionsData.body === 'string') {
                            try { actualSessions = JSON.parse(sessionsData.body); }
                            catch (e) { console.error(`WDC: Failed to parse sessionsData.body string:`, e, sessionsData.body.substring(0,300)); actualSessions = []; }
                        } else { actualSessions = sessionsData.body; }
                    } else { actualSessions = sessionsData; }
            
                    if (!actualSessions || !Array.isArray(actualSessions) || actualSessions.length === 0) {
                        console.log(`WDC: No sessions found in API response for ${targetDateString}.`);
                        tableau.log(`No sessions found for ${targetDateString}.`);
                        doneCallback();
                        return; 
                    }
                    
                    sessionsFoundOverall = actualSessions.length;
                    console.log(`WDC: Found ${actualSessions.length} sessions for ${targetDateString}.`);
            
                    // Process a limited number of sessions found on that day for testing
                    const sessionsToProcess = actualSessions.slice(0, 5); // Process up to the first 5 sessions found
                    
                    for (const session of sessionsToProcess) {
                        if (!session.sessionId) {
                            console.warn("WDC: Session object missing sessionId:", session);
                            continue;
                        }
                        tableau.reportProgress(`Processing session ${session.sessionId.substring(0,8)}... for date ${targetDateString}`);
            
                        // 1. Fetch Ball Data
                        let actualPitchDataForSession = [];
                        const pitchDataUrl = config.proxyUrl + encodeURIComponent(`${config.apiBase}/data/game/balls/${session.sessionId}`);
                        console.log(`WDC: Fetching ball data for session: ${session.sessionId}`);
                        try {
                            const pitchResponse = await fetch(pitchDataUrl, {
                                method: 'GET',
                                headers: { 'Accept': 'application/json', 'Authorization': 'Bearer ' + tableau.password }
                            });
                            if (pitchResponse.ok) {
                                const pitchDataResult = await pitchResponse.json();
                                actualPitchDataForSession = (pitchDataResult && typeof pitchDataResult.body === 'string' ? JSON.parse(pitchDataResult.body) : pitchDataResult.body) || pitchDataResult;
                                if (!Array.isArray(actualPitchDataForSession)) actualPitchDataForSession = [];
                                console.log(`WDC: Fetched ${actualPitchDataForSession.length} ball entries for session ${session.sessionId}.`);
                            } else {
                                console.warn(`WDC: Ball data fetch failed for session ${session.sessionId}. Status: ${pitchResponse.status}`);
                            }
                        } catch (fetchError) {
                            console.error(`WDC: Fetch for ball data failed for session ${session.sessionId}:`, fetchError.toString());
                        }
            
                        // 2. Fetch Plays Data
                        let actualPlaysDataForSession = [];
                        const playsUrl = config.proxyUrl + encodeURIComponent(`${config.apiBase}/data/game/plays/${session.sessionId}`);
                        console.log(`WDC: Fetching plays data for session: ${session.sessionId}`);
                         try {
                            const playsResponse = await fetch(playsUrl, {
                                method: 'GET',
                                headers: { 'Accept': 'application/json', 'Authorization': 'Bearer ' + tableau.password }
                            });
                            if (playsResponse.ok) {
                                const playsResult = await playsResponse.json();
                                actualPlaysDataForSession = (playsResult && typeof playsResult.body === 'string' ? JSON.parse(playsResult.body) : playsResult.body) || playsResult;
                                if (!Array.isArray(actualPlaysDataForSession)) actualPlaysDataForSession = [];
                                console.log(`WDC: Fetched ${actualPlaysDataForSession.length} plays for session ${session.sessionId}.`);
                            } else {
                                console.warn(`WDC: Plays data fetch failed for session ${session.sessionId}. Status: ${playsResponse.status}`);
                            }
                        } catch (fetchError) {
                            console.error(`WDC: Fetch for plays data failed for session ${session.sessionId}:`, fetchError.toString());
                        }
            
                        // 3. Map and Combine
                        if (actualPitchDataForSession && actualPitchDataForSession.length > 0) {
                            const mappedRows = actualPitchDataForSession.filter(item => item.kind === 'Pitch').map(item => {
                                const playInfo = actualPlaysDataForSession.find(p => p.playID === item.playId);
                                pitchesFoundOverall++;
                                return { // Map to schema columns
                                    sessionId: session.sessionId, playId: item.playId, trackId: item.trackId, trackStartTime: item.trackStartTime,
                                    kind: item.kind, relSpeed: item.pitch?.release?.relSpeed, spinRate: item.pitch?.release?.spinRate,
                                    extension: item.pitch?.release?.extension, vertRelAngle: item.pitch?.release?.vertRelAngle,
                                    horzRelAngle: item.pitch?.release?.horzRelAngle, relHeight: item.pitch?.release?.relHeight,
                                    relSide: item.pitch?.release?.relSide, horzBreak: item.pitch?.movement?.horzBreak,
                                    vertBreak: item.pitch?.movement?.vertBreak, inducedVertBreak: item.pitch?.movement?.inducedVertBreak,
                                    spinAxis: item.pitch?.movement?.spinAxis, tilt: item.pitch?.movement?.tilt,
                                    zoneTime: item.pitch?.location?.zoneTime, plateLocHeight: item.pitch?.location?.plateLocHeight,
                                    plateLocSide: item.pitch?.location?.plateLocSide, zoneSpeed: item.pitch?.location?.zoneSpeed,
                                    vertApprAngle: item.pitch?.location?.vertApprAngle, horzApprAngle: item.pitch?.location?.horzApprAngle,
                                    pfxx: item.pitch?.pfxData?.pfxx, pfxz: item.pitch?.pfxData?.pfxz, effVelocity: item.pitch?.pfxData?.effVelocity,
                                    pitcherName: playInfo?.pitcher?.name, batterName: playInfo?.batter?.name,
                                    pitchNo: playInfo?.taggerBehavior?.pitchNo || item.taggerPitch?.pitchNo,
                                    inning: playInfo?.gameState?.inning || item.gameState?.inning,
                                    balls: playInfo?.gameState?.balls !== undefined ? playInfo.gameState.balls : item.gameState?.balls,
                                    strikes: playInfo?.gameState?.strikes !== undefined ? playInfo.gameState.strikes : item.gameState?.strikes,
                                    outs: playInfo?.gameState?.outs !== undefined ? playInfo.gameState.outs : item.gameState?.outs,
                                    taggedPitchType: playInfo?.pitchTag?.taggedPitchType || item.pitchTag?.taggedPitchType,
                                    pitchCall: playInfo?.pitchTag?.pitchCall || item.pitchTag?.pitchCall
                                };
                            });
                            allRowsCollected = allRowsCollected.concat(mappedRows);
                        }
                    } // End loop through sessions found on the target date
            
                    if (allRowsCollected.length > 0) {
                        console.log(`WDC: Appending ${allRowsCollected.length} total rows for ${targetDateString} to Tableau table.`);
                        table.appendRows(allRowsCollected);
                    } else {
                        console.log(`WDC: No processable pitch data rows to append for ${targetDateString}.`);
                        if (sessionsFoundOverall > 0) {
                            tableau.log(`Found ${sessionsFoundOverall} sessions for ${targetDateString}, but no pitch data could be retrieved/mapped from them, or no pitches in those sessions.`);
                        } else {
                            tableau.log(`No sessions were found for ${targetDateString}.`); // This message is already logged above if no sessions
                        }
                    }
                    doneCallback();
            
                } catch (error) {
                    console.error("WDC: Error in fetchAllDataHistorically (Single Day Test):", error.toString(), error.stack);
                    tableau.abortWithError("Failed during single day data fetch: " + error.toString());
                }
            }

                // 3. Map and Combine
                if (actualPitchDataForSession && actualPitchDataForSession.length > 0) {
                    const mappedRows = actualPitchDataForSession.filter(item => item.kind === 'Pitch').map(item => {
                        const playInfo = actualPlaysDataForSession.find(p => p.playID === item.playId);
                        pitchesFoundOverall++;
                        return { // Map to schema columns
                            sessionId: session.sessionId, playId: item.playId, trackId: item.trackId, trackStartTime: item.trackStartTime,
                            kind: item.kind, relSpeed: item.pitch?.release?.relSpeed, spinRate: item.pitch?.release?.spinRate,
                            extension: item.pitch?.release?.extension, vertRelAngle: item.pitch?.release?.vertRelAngle,
                            horzRelAngle: item.pitch?.release?.horzRelAngle, relHeight: item.pitch?.release?.relHeight,
                            relSide: item.pitch?.release?.relSide, horzBreak: item.pitch?.movement?.horzBreak,
                            vertBreak: item.pitch?.movement?.vertBreak, inducedVertBreak: item.pitch?.movement?.inducedVertBreak,
                            spinAxis: item.pitch?.movement?.spinAxis, tilt: item.pitch?.movement?.tilt,
                            zoneTime: item.pitch?.location?.zoneTime, plateLocHeight: item.pitch?.location?.plateLocHeight,
                            plateLocSide: item.pitch?.location?.plateLocSide, zoneSpeed: item.pitch?.location?.zoneSpeed,
                            vertApprAngle: item.pitch?.location?.vertApprAngle, horzApprAngle: item.pitch?.location?.horzApprAngle,
                            pfxx: item.pitch?.pfxData?.pfxx, pfxz: item.pitch?.pfxData?.pfxz, effVelocity: item.pitch?.pfxData?.effVelocity,
                            pitcherName: playInfo?.pitcher?.name, batterName: playInfo?.batter?.name,
                            pitchNo: playInfo?.taggerBehavior?.pitchNo || item.taggerPitch?.pitchNo,
                            inning: playInfo?.gameState?.inning || item.gameState?.inning,
                            balls: playInfo?.gameState?.balls !== undefined ? playInfo.gameState.balls : item.gameState?.balls,
                            strikes: playInfo?.gameState?.strikes !== undefined ? playInfo.gameState.strikes : item.gameState?.strikes,
                            outs: playInfo?.gameState?.outs !== undefined ? playInfo.gameState.outs : item.gameState?.outs,
                            taggedPitchType: playInfo?.pitchTag?.taggedPitchType || item.pitchTag?.taggedPitchType,
                            pitchCall: playInfo?.pitchTag?.pitchCall || item.pitchTag?.pitchCall
                        };
                    });
                    allRowsCollected = allRowsCollected.concat(mappedRows);
                }
            } // End loop through sessions in chunk

            // Prepare for the next older chunk: set currentChunkEndDate to the day BEFORE the start of the chunk we just processed
            currentChunkEndDate.setDate(chunkStartDate.getDate() - 1); 
            console.log(`WDC: End of Chunk ${i + 1}. Total rows collected so far: ${allRowsCollected.length}`);
        } // End of loop for historical chunks

        if (allRowsCollected.length > 0) {
            console.log(`WDC: Appending ${allRowsCollected.length} total rows to Tableau table.`);
            table.appendRows(allRowsCollected);
        } else {
            console.log("WDC: No data rows to append after processing all historical chunks.");
            if (sessionsFoundOverall > 0) {
                tableau.log(`Found ${sessionsFoundOverall} sessions, but no processable pitch data.`);
            } else {
                tableau.log("No sessions found for the entire historical period scanned.");
            }
        }
        doneCallback();

    } catch (error) {
        console.error("WDC: Error in fetchAllDataHistorically:", error.toString(), error.stack);
        tableau.abortWithError("Failed during historical data fetch: " + error.toString());
    }
}

    // Register the connector
    if (typeof tableau !== 'undefined' && tableau.makeConnector) {
        tableau.registerConnector(myConnector);
        console.log("WDC: Connector registered with Tableau.");
    } else {
        console.error('WDC: Cannot register connector: tableau object or tableau.makeConnector not available.');
        document.addEventListener('DOMContentLoaded', function() {
            const errDiv = document.getElementById('error-message');
            if (errDiv) errDiv.style.display = 'block';
            const button = document.getElementById('connectButton');
            if (button) button.disabled = true;
        });
    }
  </script>
</head>
<body>
  <h1>TrackMan Tableau Web Data Connector v12</h1>
  <div id="error-message" style="display:none; color:red; margin:10px 0; padding:10px; border: 1px solid red;">
    </div>
  <p><strong>API Version:</strong> Uses Netlify serverless function (tmapi.netlify.app) to proxy API requests.</p>
  <p><strong>Mode:</strong> Attempts historical data load (approx. last 3-4 months from end of Oct 2024, in 28-day chunks). Adjust dates in code if needed.</p>
  <button id="connectButton" onclick="if(typeof tableau !== 'undefined' && tableau.connectionName !== undefined) { tableau.connectionName='TrackMan API v12'; tableau.submit(); } else { alert('This button must be run within Tableau Desktop\'s Web Data Connector interface after the WDC library has loaded.'); }">
    Connect to TrackMan API v12
  </button>
</body>
</html>
