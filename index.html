// In your index.html, replace the existing getOAuthToken function with this:
function getOAuthToken() {
    // Removed the check for existing tableau.password to force a new fetch every time.
    console.log("WDC: Fetching new OAuth token (forced for every call to getOAuthToken).");

    // IMPORTANT: The token request itself MUST also go through the proxy.
    const proxiedTokenUrl = config.proxyUrl + encodeURIComponent(config.oauthUrl);
    const body = `grant_type=client_credentials&client_id=${config.clientId}&client_secret=${config.clientSecret}`;

    console.log("WDC: Requesting token from proxied URL:", proxiedTokenUrl);

    return fetch(proxiedTokenUrl, { // Use the proxied URL
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept': 'application/json'
        },
        body: body
    })
    .then(response => {
        console.log("WDC: getOAuthToken response status:", response.status);
        if (!response.ok) {
            return response.text().then(text => {
                console.error("WDC: getOAuthToken error response body (from proxy):", text);
                // Try to parse the text in case the proxy returned a JSON error object from the actual token endpoint
                try {
                    const errorData = JSON.parse(text);
                    if (errorData.error && errorData.error.error) { // Check if it's a nested error from proxy then target
                         throw new Error(`Token request failed: ${response.status} - ${errorData.error.error} - ${errorData.error.error_description || ''}`);
                    } else if (errorData.error) {
                         throw new Error(`Token request failed: ${response.status} - ${errorData.error} - ${errorData.error_description || ''}`);
                    }
                } catch (e) {
                    // Not JSON or not the expected error structure
                }
                throw new Error(`Token request failed: ${response.status} ${response.statusText} - Raw Text: ${text.substring(0,300)}`);
            });
        }
        return response.json();
    })
    .then(data => {
        // The proxy wraps the actual response. So data here is what the proxy returned.
        // We need to check if data.body is the actual token response.
        let tokenData = data;
        // If the proxy structure returns the target's body inside a 'body' field (and it's a string needing parsing)
        if (typeof data.body === 'string') {
            try {
                tokenData = JSON.parse(data.body);
            } catch (e) {
                console.error("WDC: Failed to parse token data from proxy's response body:", data.body);
                throw new Error("Failed to parse token data from proxy response.");
            }
        } else if (data.body) { // If data.body is already an object
            tokenData = data.body;
        }
        // If there's no 'body' field, assume 'data' is the direct response (less likely with current proxy but good to check)


        if (tokenData.error) {
            console.error("WDC: OAuth Error (from token endpoint):", tokenData.error, tokenData.error_description);
            throw new Error(tokenData.error_description || tokenData.error);
        }
        if (!tokenData.access_token) {
            console.error("WDC: access_token not found in OAuth response:", tokenData);
            throw new Error("Access token not found in OAuth response.");
        }
        console.log("WDC: New OAuth token fetched successfully via proxy.");
        if(tokenData.exp) {
            console.log("WDC: Token 'exp' claim: " + new Date(tokenData.exp * 1000));
        } else if (tokenData.expires_in) {
            const expiryDate = new Date(Date.now() + tokenData.expires_in * 1000);
            console.log("WDC: Token 'expires_in': " + tokenData.expires_in + "s. Approx expiry: " + expiryDate);
        }
        return tokenData.access_token;
    })
    .catch(error => {
        console.error("WDC: Error in getOAuthToken:", error.toString());
        return Promise.reject("Failed to fetch OAuth token: " + error.toString());
    });
}

// And in myConnector.getData, ensure it calls this new getOAuthToken:
myConnector.getData = function(table, doneCallback) {
    console.log("WDC: myConnector.getData called for table:", table.tableInfo.id);

    getOAuthToken().then(freshToken => {
        tableau.password = freshToken; // Store the fresh token
        console.log("WDC: Fresh token obtained and stored in tableau.password for getData call.");

        if (table.tableInfo.id === config.schemaIdGameSessions) {
            fetchGameSessions(table, doneCallback); // fetchGameSessions will use the new tableau.password
        } else if (table.tableInfo.id === config.schemaIdPitchData) {
            fetchPitchData(table, doneCallback); // fetchPitchData will use the new tableau.password
        } else {
            tableau.abortWithError("WDC: Unknown table ID in getData: " + table.tableInfo.id);
        }
    }).catch(err => {
        console.error("WDC: Failed to get fresh token for getData:", err);
        tableau.abortWithError("WDC: Failed to get fresh token for getData: " + err.toString());
    });
};
